# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ExampleDialog
                                 A QGIS plugin
 This is example plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-12-13
        git sha              : $Format:%H$
        copyright            : (C) 2023 by xyz pvt.ltd
        email                : xyz@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsRasterLayer, QgsProject, QgsMessageLog, QgsApplication
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from qgis.gui import QgsMessageBar
from osgeo import gdal
import geopandas as pd
import rasterio as rs
import matplotlib.pyplot as plt
import os
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
import numpy as np
import time
import joblib
# import algorithms
from sklearn.linear_model import LogisticRegression
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Example_dialog_base.ui'))


class ExampleDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(ExampleDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.tif_file_path = None
        self.train_data_path = None
        self.selected_column = None
        self.current_algorithm = None
        self.output_directory = None
        self.labelsinfo = None
        self.totalstep=100
        self.currentstep=0
        self.setupUi(self)
        self.okpushButton.clicked.connect(self.ok_push_event)
        self.cancelpushButton.clicked.connect(self.cancelPushButton_event)
        self.qgsInputFile.lineEdit().textChanged.connect(self.input_file_event)
        self.qgsTrainingData.lineEdit().textChanged.connect(self.input_train_data_event)
        self.selectAlgorithms.currentIndexChanged.connect(self.select_algorithm_event)
        self.ColumnsBox.currentIndexChanged.connect(self.select_column)
        self.qgsoutputFile.lineEdit().textChanged.connect(self.select_output_directory)
        self.saveModelCheckBox.stateChanged.connect(self.save_model)
        self.progressBar.setRange(0, 100)
    #     check box signal

    def ok_push_event(self):
        if self.tif_file_path is not None:
            # self.add_to_layer(self.tif_file_path)
            self.setProgressBarValue(10)
            self.extract_pixel_value()
            self.setProgressBarValue(20)
            time.sleep(1)
            self.setProgressBarValue(30)
            time.sleep(1)
            self.setProgressBarValue(40)
            time.sleep(1)
            self.setProgressBarValue(50)
            time.sleep(1)
            final_df = self.filter_train_data()
            self.setProgressBarValue(60)
            time.sleep(1)
            self.setProgressBarValue(70)
            model,scaler=self.classify_(final_df)
            self.setProgressBarValue(80)
            time.sleep(1)
            self.setProgressBarValue(90)
            self.generate_output(model,scaler,final_df)
            self.setProgressBarValue(100)
            self.progressBar.reset()
            self.save_model(model)
        else:
            # message box implementation
            print("Empty path !")

    # Cancel Button Clicked EVent Handler
    def cancelPushButton_event(self):
        self.close()

    def save_model(self,model):
        if self.saveModelCheckBox.isChecked():
            joblib.dump(model,fr"{self.output_directory}\model.pkl")
    def input_file_event(self, file_path):
        self.tif_file_path = file_path
        print(self.tif_file_path)

    def input_train_data_event(self, file_path):
        self.train_data_path = file_path
        print(self.train_data_path)
        if self.train_data_path:
            self.selectColumnLabel.setEnabled(True)
            self.ColumnsBox.setEnabled(True)
            handletraintask = FileLoadTask(self.train_data_path)
            df_file = handletraintask.df_file
            for i in df_file.columns:
                self.ColumnsBox.addItem(i)

    def select_column(self, index):
        self.selected_column = self.ColumnsBox.currentText()
        print(self.selected_column)

    def select_algorithm_event(self, index):
        algorithms={'LogisticRegression':LogisticRegression(),'DecisionTreeClassifier':DecisionTreeClassifier(),
                    'RandomForestClassifier':RandomForestClassifier(),
                    'KNeighborsClassifier':KNeighborsClassifier(),
                    'Support Vector Machine':SVC()
                    }
        self.current_algorithm = algorithms[self.selectAlgorithms.currentText()]

    def my_task(self):
        print("Task Started")

    def add_to_layer(self, file_path):
        file_layer = QgsRasterLayer(fr"{file_path}", file_path)
        QgsProject.instance().addMapLayer(file_layer)

    def select_output_directory(self, file_path):
        self.output_directory = file_path
        print(self.output_directory)

    def extract_pixel_value(self):
        print("Pixel value extraction started...")
        if self.tif_file_path is not None and self.train_data_path is not None and self.output_directory is not None:
            raster_file = rs.open(fr"{self.tif_file_path}")
            df = pd.read_file(fr"{self.train_data_path}")
            df.to_crs(raster_file.crs, inplace=True)
            total_bands = raster_file.count
            bands = [f"BAND_{i}" for i in range(1, total_bands + 1)]
            for i in range(0, total_bands):
                band_info = raster_file.read(i + 1)
                for j in range(0, len(df)):
                    point = df.loc[j, 'geometry']
                    #         convert into pixel x and pixel y
                    pixel_x, pixel_y = raster_file.index(point.x, point.y)
                    pixel_value = band_info[pixel_x, pixel_y]
                    df.loc[j, bands[i]] = pixel_value
            #             save the data frame in shape file format
            df.to_file(fr"{self.output_directory}\myshp.shp", driver="ESRI Shapefile")
            print("Pixel value extraction ended")

    def filter_train_data(self):
        if self.tif_file_path is not None and self.train_data_path is not None and self.output_directory is not None:
            if os.path.exists(fr"{self.output_directory}\myshp.shp") == True:
                df = pd.read_file(fr"{self.output_directory}\myshp.shp")
                columns = self.select_columns(df)
                print("Columns got selected")
                columns.append(self.selected_column)
                df = df[columns]
                print(df)
                return df

    def classify_(self, df):
        print("Split train test started")
        X = df.drop(columns=[self.selected_column])
        Y = df[self.selected_column]
        X_train, X_test, y_train, y_test = train_test_split(X, Y, random_state=10, train_size=0.7)
        scaler = StandardScaler()
        X_train = scaler.fit_transform(X_train)
        X_test = scaler.transform(X_test)
        model = self.train_model(X_train, y_train)
        self.test_model(model, X_test, y_test)
        return model,scaler

    def train_model(self, X_train, y_train):
        print("training started...")
        # for now random forest
        model=self.current_algorithm
        model.fit(X_train, y_train)
        return model

    def test_model(self, model, X_test, y_test):
        print("Testing started...")
        y_predicted = model.predict(X_test)
        report = classification_report(y_test, y_predicted, output_dict=True)
        #     generate report file
        report_file = pd.GeoDataFrame(report).transpose()
        report_file.to_csv(fr"{self.output_directory}\classification_report.csv")
        #   generate confusion matrix
        matrix = confusion_matrix(y_test, y_predicted)
        figure = ConfusionMatrixDisplay(matrix, display_labels=model.classes_)
        figure.plot().figure_.savefig(fr"{self.output_directory}\confusionmatrix.png", dpi=100)
        print("Generation completed !!!")

    def generate_output(self, model, scaler,df):
        print("Generate output started...")
        raster_file = rs.open(self.tif_file_path)
        #     get shape of one band
        shape_of_band= raster_file.read(1).shape
        #  read as array
        raster_data = raster_file.read()
        raster_data = np.array(raster_data, dtype=np.float64)
    #     do prediction for whole raster file
        print("prediction started.....")
        raster_data=raster_data.transpose()
        raster_data = raster_data.reshape(-1,raster_file.count)
        scaled_value = scaler.transform(raster_data)
        predicted=model.predict(scaled_value)
    #     make labels
        labels=self.generate_label(df)
    # map value according to label
        predicted_list = []
        for i in predicted.tolist():
                predicted_list.append(labels[i])

    # change it into array
        print(f"predicted list:{predicted_list}")
        array_predicted = np.dstack(predicted_list)
        print("Predicted array to dstack....")
    # read information from gdal
        raster_file = gdal.Open(fr"{self.tif_file_path}")
    #   write raster file
        driver= gdal.GetDriverByName("GTiff")#getting driver
        output = driver.Create(fr"{self.output_directory}\output.tif",raster_file.RasterXSize,raster_file.RasterYSize, 1, gdal.GDT_Float64)
        output.SetGeoTransform(raster_file.GetGeoTransform())
        output.SetProjection(raster_file.GetProjection())
        # transform it into shape of band
        print("transformation started...")
        array_predicted = array_predicted.reshape(1,shape_of_band[1],shape_of_band[0])
        print("Raster write from array started...")
        print(array_predicted)
        output.GetRasterBand(1).WriteArray(array_predicted[0].transpose())
        print("writing finished ....")
    #     add to qgis layer
        layer=QgsRasterLayer(fr"{self.output_directory}\output.tif")
        QgsProject.instance().addMapLayer(layer)




    def generate_label(self, df):
        mylabels = {}
        for index, value in enumerate(df[self.selected_column].unique()):
            mylabels[value] = index + 1
        return mylabels

    #     change into float 64 type
    def map_output_column(self, df):
        unique_values = df[self.selected_column].unique()
        mylabels = {}
        for index, value in enumerate(df['ClassType'].unique()):
            mylabels[value] = index + 1
        return mylabels

    def select_columns(self, df):
        bands_columns = []
        for i in df.columns:
            if i.startswith('BAND'):
                bands_columns.append(i)
        return bands_columns

    def setProgressBarValue(self,value):
        self.progressBar.setValue(value)


class FileLoadTask:
    def __init__(self, train_data_path):
        print("Handle train task started")
        self.train_data_path = train_data_path
        try:
            self.df_file = pd.read_file(fr"{self.train_data_path}")
        except:
            print("Error occured")
